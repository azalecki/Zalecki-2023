---
title: "Analysis of Neighborhood Characteristics of Library Catchment Areas in Chicago, IL"
author: "Alexandra Ola Zalecki"
date: "`r Sys.Date()`"
output: html_document
editor_options:
  markdown:
    wrap: sentence
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../../docs/report") })
---

# Abstract

Rising inequality and increased privatization of space in urban landscapes is bringing attention to some of the only public spaces left: libraries. This study analyzes to what extent library service areas differ along lines of inequality like race, class, etc. This study will delineate library catchment areas in Chicago, IL and compare them with socio-economic data at the tract and block level. This analysis is the first part of a two pronged methods that aims to answer the question of to what extent the catchment areas are distinct. 

## Study Metadata

- `Key words`: public space, libraries, population weighted aggregation, service areas, demographics 
- `Subject`: Social and Behavioral Sciences: Geography: Human Geography
- `Date created`: 11/28/2023
- `Date modified`: 1/28/2024
- `Spatial Coverage`: Chicago, IL
- `Spatial Resolution`: Census Tracts, Census Blocks, Library Service Areas
- `Spatial Reference System`: EPSG:32616 
- `Temporal Coverage`: 2017-Present
- `Temporal Resolution`: Specify the temporal resolution of your study---i.e. the duration of time for which each observation represents or the revisit period for repeated observations

# Study design

This study is a reproduction of my own **an original study**. As part of my independent research work with Professor Peter Nelson, I created a workflow in QGIS to answer the question: How do library service catchment areas differ along lines of race, class, gender, etc? In order to streamline this research and make it reproducible/replicable I decided to reproduce the workflow in R and create a research compendium for it as part of my final independent project in GEOG0361: Open GIScience.

This research aims to answer the following two questions. How do library service catchment areas differ along lines of race, class, gender, etc. How do the public services in these catchment areas reflect the nature of their local constituents? 


# Materials and procedure

## Computational environment

```{r environment-setup, warning = FALSE}
# record all the packages you are using here
# this includes any calls to library(), require(),
# and double colons such as here::i_am()
packages <- c( 
  "tidycensus", "tidyverse", "sf", "classInt", "readr", "tigris",
  "rgdal","rstudioapi", "here", "s2", "pastecs", "tmap", "knitr", 
  "kableExtra", "broom", "leaflet", "usethis", "deldir", "spatstat", "webshot"
)

# force all conflicts to become errors
# if you load dplyr and use filter(), R has to guess whether you mean dplyr::filter() or stats::filter()
# the conflicted package forces you to be explicit about this
# disable at your own peril
# https://conflicted.r-lib.org/
require(conflicted)

# load and install required packages
# https://groundhogr.com/
if (!require(groundhog)) {
  install.packages("groundhog")
  require(groundhog)
}

if(!require(here)){
  install.packages("here")
  require(here)
}

# this date will be used to determine the versions of R and your packages
# it is best practice to keep R and its packages up to date
groundhog.day <- "2023-06-26"
set.groundhog.folder("../../data/scratch/groundhog/")

# this replaces any library() or require() calls
groundhog.library(packages, groundhog.day)
# you may need to install a correct version of R
# you may need to respond OK in the console to permit groundhog to install packages
# you may need to restart R and rerun this code to load installed packages
# In RStudio, restart r with Session -> Restart Session

# record the R processing environment
# alternatively, use devtools::session_info() for better results
writeLines(
  capture.output(sessionInfo()),
  here("procedure", "environment", paste0("r-environment-", Sys.Date(), ".txt"))
)

# save package citations
knitr::write_bib(c(packages, "base"), file = here("software.bib"))

# set up default knitr parameters
# https://yihui.org/knitr/options/
knitr::opts_chunk$set(
  echo = FALSE, # Run code, show outputs (don't show code)
  fig.retina = 4,
  fig.width = 8,
  fig.path = paste0(here("results", "figures"), "/")
)

#Switch the graphics output from raster to vector
knitr::opts_chunk$set(dev="png")

```
## Data and variables

Each of the next subsections describes one data source.
Primary data sources are to include the following. 

```{r load-website-data}
```

Secondary data sources for the study are to include the following. 

### Chicago Shapefile 

```{r download-places, eval= FALSE}
# Load in all places defined by the US Census 
il_places <- places(state = "IL")

il_places

saveRDS(il_places, here("data", "raw", "public", "il_places.RDS"))

```

```{r load-clip-places}

# Load Census places for Illinois
il_places <- readRDS(here("data", "raw", "public", "il_places.RDS"))

# Filter out Chicago from Census Places

chi <- il_places %>%
  dplyr::filter(NAME == 'Chicago')%>%
  st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

# Plot geometry

plot(chi$geometry)

```

```{r download-tracts-shp, eval= FALSE}

cook_tracts <- tracts(
                state = "IL",
                county = "Cook",
                cb = FALSE,
                resolution = "500k",
                year = 2020)%>%
  st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

saveRDS(cook_tracts, here("data", "raw", "public", "cook_tracts.RDS"))

```

```{r load-tracts-shp}

#Load in tracts for Chicago 

cook_tracts <- readRDS(here("data", "raw", "public", "cook_tracts.RDS"))

```
### American Community Survey(ACS) Demographic Data 

In order to simplify the workflow for this independent project I will be working with one variable, household, income that is derived from ACS data table B19001. Household income data is referenced at the Census tract level for the whole of Cook County. The year derived is 2021. 

I will add a more comprehensive list of variables as my senior research project progresses.

```{r api-key, install = TRUE}
# Load in Census API Key. To get your own key visit this website: 

census_api_key("058bab25964a0d33dc97ba789df8df55ba443855")
```

```{r query-acs-data, eval = FALSE}

# Query Social & Demographic data tables with Census tract boundaries

 # Age and Sex Table 

  as_acs <- get_acs(
    geography = "tract",
    table = "B01001",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_drop_geometry()

 # Race & Ethnicity Table
 
  race_acs <- get_acs(
    geography = "tract",
    table = "B03002",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_drop_geometry()
  
  # Household Type 
  
  hhold_acs <- get_acs(
    geography = "tract",
    table = "B11003",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_drop_geometry()
  
  # Educational Attainment Table 

  edu_acs <- get_acs(
    geography = "tract",
    table = "B15003",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_drop_geometry()
  
  # Disability Status Table 
  
  dis_acs <- get_acs(
    geography = "tract",
    table = "B18101",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_drop_geometry()

  # School Enrollment 
 
  enr_acs <- get_acs(
    geography = "tract",
    table = "B14001",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_drop_geometry()
 
# Employment Table 

  emp_acs <- get_acs(
    geography = "tract",
    table = "B23025",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_drop_geometry()
 
# Nativity Table 
 
  nat_acs <- get_acs(
    geography = "tract",
    table = "B05012",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_drop_geometry()
 
# Language Spoken at Home

   lang_acs <- get_acs(
     geography = "tract",
     table = "B06007",
     county = "Cook",
     state = "IL",
     year = 2016,
     output = "wide",
     cache_table = TRUE,
     geometry = TRUE,
     keep_geo_vars = TRUE)%>%
     st_drop_geometry()
 
# Computers at Home
 
  comp_acs <- get_acs(
    geography = "tract",
    table = "B28010",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
     st_drop_geometry()
 
 # Household Income Table 
inc_acs <- get_acs(
   geography = "tract",
   table = "B19001",
   county = "Cook",
   state = "IL",
   year = 2021,
   output = "wide",
   cache_table = TRUE,
   geometry = TRUE,
   keep_geo_vars = TRUE)%>%
    st_drop_geometry()

m_inc_acs <- get_acs(
   geography = "tract",
   table = "B19013",
   county = "Cook",
   state = "IL",
   year = 2021,
   output = "wide",
   cache_table = TRUE,
   geometry = TRUE,
   keep_geo_vars = TRUE) %>%
  st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

# Save query results

saveRDS(edu_acs, here("data", "raw", "public", "edu_acs.RDS"))
saveRDS(as_acs, here("data", "raw", "public", "as_acs.RDS"))
saveRDS(race_acs, here("data", "raw", "public", "race_acs.RDS"))
saveRDS(hhold_acs, here("data", "raw", "public", "hhold_acs.RDS"))
saveRDS(dis_acs, here("data", "raw", "public", "dis_acs.RDS"))
saveRDS(enr_acs, here("data", "raw", "public", "enr_acs.RDS"))
saveRDS(emp_acs, here("data", "raw", "public", "emp_acs.RDS"))
saveRDS(nat_acs, here("data", "raw", "public", "nat_acs.RDS"))
saveRDS(lang_acs, here("data", "raw", "public", "lang_acs.RDS"))
saveRDS(comp_acs, here("data", "raw", "public", "comp_acs.RDS"))
saveRDS(inc_acs, here("data", "raw", "public", "inc_acs.RDS"))
saveRDS(m_inc_acs, here("data", "raw", "public", "m_inc_acs.RDS"))

```

```{r load-queried-acs-data}

#Load ACS Data 

edu_acs <- readRDS(here("data", "raw", "public", "edu_acs.RDS"))
as_acs <- readRDS(here("data", "raw", "public", "as_acs.RDS"))
race_acs <- readRDS(here("data", "raw", "public", "race_acs.RDS"))
hhold_acs <- readRDS(here("data", "raw", "public", "hhold_acs.RDS"))
dis_acs <- readRDS(here("data", "raw", "public", "dis_acs.RDS"))
enr_acs <- readRDS(here("data", "raw", "public", "enr_acs.RDS"))
emp_acs <- readRDS(here("data", "raw", "public", "emp_acs.RDS"))
nat_acs <- readRDS(here("data", "raw", "public", "nat_acs.RDS"))
lang_acs <- readRDS(here("data", "raw", "public", "lang_acs.RDS"))
comp_acs <- readRDS(here("data", "raw", "public", "comp_acs.RDS"))
inc_acs <- readRDS(here("data", "raw", "public", "inc_acs.RDS"))
m_inc_acs <- readRDS(here("data", "raw", "public", "m_inc_acs.RDS"))

```

### Public Library Locations

Data for Chicago Public Library locations comes in CSV format with coordinate data. Prior to uploading the CSV file into the Github site I used Microsoft Excel to manually separate the Longitude and Latitude values into two separate columns. No other data manipulation was done in Excel. 

```{r cpl-data, warning = FALSE, dpi=30, out.width="500px", out.height="500px"}

#Load Chicago Public Library addresses from CSV file found in Folder: data/raw/public/CPL-Locations.csv

cpl_data = read_csv("https://raw.githubusercontent.com/azalecki/Zalecki-2023/main/data/raw/public/CPL-Locations.csv")

# Create points layer using Longitude and Latitude columns and set projection to UTM Zone 16, EPSG: 32616

points <- cpl_data %>%
  st_as_sf(coords = c("Longitude", "Latitude")) %>%
  st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

# Check class and geometry type of data 

class(points)
st_geometry_type(points)

# Plot points on map with Chicago boundary 

tmap_mode("plot")
tm_shape(chi) + 
  tm_borders() +
tm_shape(points) +
tm_dots(size=0.1, col = "red")

# cpl_points_m <- leaflet() %>% 
#                    addProviderTiles(providers$Esri.WorldGrayCanvas) %>% 
#                    addPolygons(data = chi, color = "gray", weight = 1, fillColor= "white", fillOpacity = 0.2)%>%
#                    addCircles(data = points, weight = 3, opacity= 1, color = "orange") 
# cpl_points_m



```

### Population Data and Census Blocks for Cook County, IL   
Because, the ACS data tables do not come with population data I have to bring in population data separately. Population data for this study is referenced at the block level for the whole of Cook County, IL. The year that the data is derived from is 2020.  

```{r download-pop-blocks, eval= FALSE}

# Query block geographic data from the 2020 Census population

blocks <- get_decennial(
  geography = "block",
  table = "P1",
  county = "Cook",
  state = "IL",
  year = 2020,
  output = "wide",
  cache_table = TRUE,
  geometry = TRUE,
  keep_geo_vars = TRUE) %>%
  st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

saveRDS(blocks, here("data", "raw", "public", "blocks.RDS"))

```

```{r load-blocks}

#Load block data 

blocks <- readRDS(here("data", "raw", "public", "blocks.RDS"))
                  
```
## Prior observations  

**Chicago Shapefile**

- [ ] data is not available yet
- [ ] data is available, but only metadata has been observed
- [X] metadata and descriptive statistics have been observed
- [ ] metadata and a pilot test subset or sample of the full dataset have been observed
- [ ] the full dataset has been observed. Explain how authors have already manipulated / explored the data.

**American Community Survey(ACS) Demographic Data** 

- [ ] data is not available yet
- [ ] data is available, but only metadata has been observed
- [X] metadata and descriptive statistics have been observed
- [ ] metadata and a pilot test subset or sample of the full dataset have been observed
- [ ] the full dataset has been observed. Explain how authors have already manipulated / explored the data.

**Public Library Locations**

- [ ] data is not available yet
- [ ] data is available, but only metadata has been observed
- [X] metadata and descriptive statistics have been observed
- [ ] metadata and a pilot test subset or sample of the full dataset have been observed
- [ ] the full dataset has been observed. Explain how authors have already manipulated / explored the data.

**Population Data and Census Blocks for Cook County, IL**  

- [ ] data is not available yet
- [ ] data is available, but only metadata has been observed
- [X] metadata and descriptive statistics have been observed
- [ ] metadata and a pilot test subset or sample of the full dataset have been observed
- [ ] the full dataset has been observed. Explain how authors have already manipulated / explored the data.


## Bias and threats to validity

**Edge/shape effects when creating polygons to represent library service/catchment areas**

Visualizing catchment areas for libraries is my first objective because, unlike primary schools that have definite attendance boundaries, libraries do not have proper "service areas." In the past, Thiessen/Voronoi polygons have been used to map catchment or service areas by proximity to points. As explained by Flitter et al(nd), GIS tools that generate Thiessen polygons draw shapes around a layer of point data where every location within one shape is nearer to its center point than all other points in the layer. These proximal regions assume that people are more likely to visit the library closest to them and as a result library services should reflect their local constituents. I recognize that this method has its flaws because this is not always the case. Some people may frequent libraries outside of their residential neighborhood for a variety of reasons and there is no way of accurately tracking that. The other option would be to draw buffers around library points like in the method we saw in the Kang et al. (year) study or calculate a network analysis. Thiessen polygons are, however, the simpler and computationally less intense option to a full-on network analysis. Although they might seem arbitrary I have attempted to improve the validity by including a population-weighted aggregation to more accurately estimate the neighborhood characteristics of the library service areas.

## Data transformations

### Block transformations
### Filter Population Blocks

Because I will be doing a population weighted aggregation I have to prepare the population data to some extent. I started by filtering out the blocks with no population data. The table of blocks that have population data was then clipped by the Chicago boundary. Then I selected for the columns that I wanted to keep working with to simplify the data table. The columns I selected for include: TRACTCE20, BLOCKCE20, GEOID, ALAND20, AWATER20, HOUSING20, POP20, geometry. 

```{r filter-blocks, warning = FALSE}

# Filter out blocks with no population data 
# Clip blocks by Chicago Boundary and simplify table by selecting for columns that I will need 

chi_pop <- blocks %>%
  dplyr::filter(POP20 > 0)%>%
  st_as_sf(st_intersection(blocks_pop, chi)%>%
  select(TRACTCE20, BLOCKCE20, GEOID, ALAND20, AWATER20, HOUSING20, POP20, geometry))%>%
  st_collection_extract("POLYGON")

#st_geometry_type(chi_pop)
#plot(chi_pop$POP20)
```

```{r leaflet-map-chi-blocks, warning = FALSE, eval = FALSE}

pal <- colorNumeric(
  palette = c("#F5FDF1", "#0D5B1E"),
  domain = chi_pop$POP20)

#binpal <- colorBin(c("#F5FDF1", "#0D5B1E"), chi_pop$POP20, 500, pretty = FALSE)

qpal <- colorQuantile(c("#F5FDF1", "#0D5B1E"), chi_pop$POP20, n = 10)

chi_pop_m <- leaflet() %>%
              addProviderTiles(providers$Esri.WorldGrayCanvas) %>%
              addPolygons(data = chi_pop, stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,color = ~qpal(POP20))#%>%
              #addPolygons(data = vor_chi, color = "#7146BD", weight = 1, fillColor= "#E7E0F4", fillOpacity = 0.2)

chi_pop_m
```

```{r map-blocks}

tmap_mode("plot")
tm_shape(chi_pop) +
  tm_polygons(col="POP20", style= "jenks", title="Population", lwd= NA, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

```

### Library Catchment Areas

To create the catchment areas I will create Thiessen/Voronoi polygons. This was done by using the st_voronoi() function on the library points data. Finally, I clipped the voronoi diagram by the Chicago shapefile. 

```{r voronoi-polygons, warning = FALSE, dpi=30, out.width="500px", out.height="500px"}

# Generate Thiessen/Voronoi polygons from library points

vorpoly <- st_union(points)%>%
  st_voronoi()%>%
  st_collection_extract("POLYGON")%>%
  st_sf %>%
  st_cast


#Plot polygons to make sure they loaded
plot(vorpoly)
#class(vorpoly)

# Rejoin attributes from library points data to voronoi polygons 
# Because I had to union the points prior to st_voronoi() function the library attributes were lost 
vorpoly2 <- st_join(vorpoly, points)

# Clip voronoi polygons by Chicago boundary 
vor_chi <- st_intersection(vorpoly2, chi)
    
# Plot polygons on a map with librayr points

vor_map <- tmap_mode("plot")
           tm_shape(vor_chi)+
              tm_borders(col="black" )+
           tm_shape(chi) + 
              tm_borders() +
           tm_shape(points) +
              tm_dots(size=0.05, col = "red")
           
vor_map

```

### ACS data transformations

The ACS classifies the data it collects in its own way but I wanted to reclassify it into different categories.

After creating the new classifications, I selected for the columns that I wanted to keep and work with. This included all of the necessary geographic identifiers(STATEFP, COUNTYFP, TRACTCE, GEOID, NAME.X, ALAND, AWATER, geometry) and the source fields I had created in the previous step. Finally, I clipped the table by the Chicago shapefile so to only include tracts that are within Chicago's city boundaries. 

```{r new-bins}

# Make new columns for Age categories 

as_acs$child <- c(as_acs$B01001_003E + 
                  as_acs$B01001_004E + 
                  as_acs$B01001_005E + 
                  as_acs$B01001_027E + 
                  as_acs$B01001_028E + 
                  as_acs$B01001_029E)

as_acs$teen <- c(as_acs$B01001_006E + 
                 as_acs$B01001_007E +
                 as_acs$B01001_030E +
                 as_acs$B01001_031E)

as_acs$yad <- c(as_acs$B01001_008E + 
                as_acs$B01001_009E + 
                as_acs$B01001_010E +
                as_acs$B01001_011E + 
                as_acs$B01001_032E + 
                as_acs$B01001_033E + 
                as_acs$B01001_034E + 
                as_acs$B01001_035E)

as_acs$mad <- c(as_acs$B01001_012E + 
                as_acs$B01001_013E +
                as_acs$B01001_014E + 
                as_acs$B01001_015E +
                as_acs$B01001_016E +
                as_acs$B01001_036E +
                as_acs$B01001_037E +
                as_acs$B01001_038E +
                as_acs$B01001_039E +
                as_acs$B01001_040E)

as_acs$sen <- c(as_acs$B01001_017E + 
                as_acs$B01001_018E + 
                as_acs$B01001_019E +
                as_acs$B01001_020E +
                as_acs$B01001_021E +
                as_acs$B01001_022E +
                as_acs$B01001_023E + 
                as_acs$B01001_024E +
                as_acs$B01001_025E +
                as_acs$B01001_041E +
                as_acs$B01001_042E +
                as_acs$B01001_043E +
                as_acs$B01001_044E +
                as_acs$B01001_045E +
                as_acs$B01001_046E +
                as_acs$B01001_047E +
                as_acs$B01001_048E +
                as_acs$B01001_049E)

as_acs$t_male <- c(as_acs$B01001_002E)
as_acs$t_fem <- c(as_acs$B01001_026E)

# Rename Race columns to make the names more intuitive 

race_acs$white <- c(race_acs$B03002_003E)
race_acs$black <- c(race_acs$B03002_004E)
race_acs$native <- c(race_acs$B03002_005E)
race_acs$asian <- c(race_acs$B03002_006E)
race_acs$hawpi <- c(race_acs$B03002_007E)
race_acs$other <- c(race_acs$B03002_008E)
race_acs$mixed <- c(race_acs$B03002_009E+ 
                      race_acs$B03002_010E + 
                      race_acs$B03002_011E)
race_acs$latinx <-c(race_acs$B03002_012E)

# Make new columns for Household Income 

inc_acs$hhi1 <- c(inc_acs$B19001_002E + 
                    inc_acs$B19001_003E + 
                    inc_acs$B19001_004E + 
                    inc_acs$B19001_005E)

inc_acs$hhi2 <- c(inc_acs$B19001_006E + 
                    inc_acs$B19001_007E + 
                    inc_acs$B19001_008E + 
                    inc_acs$B19001_009E + 
                    inc_acs$B19001_010E)

inc_acs$hhi3 <- c(inc_acs$B19001_011E +
                    inc_acs$B19001_012E)
inc_acs$hhi4 <- c(inc_acs$B19001_013E)

inc_acs$hhi5 <- c(inc_acs$B19001_014E + 
                    inc_acs$B19001_015E)

inc_acs$hhi6 <- c(inc_acs$B19001_016E)
inc_acs$hhi7 <- c(inc_acs$B19001_017E) 


# Make new columns for Employment status
# emp1 : civilian labor employed | emp0: civilian labor unemployed

 emp_acs$emp0 <- emp_acs$B23025_007E
 emp_acs$emp1 <- (emp_acs$B23025_002E)

# Rename columns for Nativity data. 
#Make new columns for Nativity status
#for0: native born | for1: foreign born

 nat_acs$for0 <- c(nat_acs$B05012_002E)
 nat_acs$for1 <- c(nat_acs$B05012_003E)

# Make new columns for Educational Attainment
# et1: no highschool diploma | et2: highschool diploma, equivalent, or some college  | et3: associates or bachelor's |et4: graduate or professional school

 edu_acs$et1 <- c(edu_acs$B15003_002E +
                    edu_acs$B15003_003E +
                    edu_acs$B15003_004E +
                    edu_acs$B15003_005E +
                    edu_acs$B15003_006E +
                    edu_acs$B15003_007E +
                    edu_acs$B15003_008E +
                    edu_acs$B15003_009E +
                    edu_acs$B15003_010E +
                    edu_acs$B15003_011E +
                    edu_acs$B15003_012E +
                    edu_acs$B15003_013E +
                    edu_acs$B15003_014E +
                    edu_acs$B15003_015E +
                    edu_acs$B15003_016E)

 edu_acs$et2 <- c(edu_acs$B15003_017E +
                    edu_acs$B15003_018E +
                    edu_acs$B15003_019E +
                    edu_acs$B15003_020E)

 edu_acs$et3 <- c(edu_acs$B15003_021E +
                    edu_acs$B15003_022E)

 edu_acs$et4 <- c(edu_acs$B15003_023E +
                    edu_acs$B15003_024E +
                    edu_acs$B15003_025E)

# Make new bins for School Enrollment by level of school
# se1: highschool or under | se2: undergraduate or graduate or professional school | se3: not enrolled in school

# enr_acs$se1 <- c(enr_acs$B14001_003E +
#                     enr_acs$B14001_004E +
#                     enr_acs$B14001_005E +
#                     enr_acs$B14001_006E +
#                     enr_acs$B14001_006E)
# 
# enr_acs$se2 <- c(enr_acs$B14001_008E + enr_acs$B14001_009E)
# 
# enr_acs$se3 <- c(enr_acs$B14001_010E)
```

```{r filter-acs}

# filter acs data by the columns that you want to keep in the new aggregate table

hhi_tab <- inc_acs %>%
  dplyr::select(TRACTCE, hhi1, hhi2, hhi3, hhi4, hhi5, hhi6, hhi7)

emp_tab <- emp_acs %>% 
  dplyr::select(TRACTCE, emp0, emp1)

nat_tab <- nat_acs %>% 
  dplyr::select(TRACTCE, for0, for1)

edu_tab <- edu_acs %>% 
  dplyr::select(TRACTCE, et1, et2, et3, et4)

race_tab <- race_acs %>% 
  dplyr::select(TRACTCE, white, black, native, asian, hawpi, mixed)

m_inc_tab <- m_inc_acs %>%
  dplyr::select(TRACTCE, B19013_001E)

as_tab <- as_acs %>% 
  dplyr::select(TRACTCE, child, teen, yad, mad, sen)

# Compile all of the ACS data that I transformed into one large table 
fc_tracts <- hhi_tab %>%
  inner_join(emp_tab)%>%
  inner_join(nat_tab)%>% 
  inner_join(edu_tab)%>% 
  inner_join(race_tab)%>%
  inner_join(m_inc_tab)%>% 
  inner_join(as_tab)%>%
  st_as_sf()

```

## Overlays and Join to Geometry 

```{r tracts-clip-chi}
# Use intersect overlay tool to clip all tracts in Cook County by Chicago's boundaries

clip_tracts <- st_intersection(cook_tracts,chi)%>%
  st_collection_extract("POLYGON")%>%
  st_drop_geometry()%>%
  left_join(fc_tracts, by= "TRACTCE")

#class(chi_tracts)

plot(clip_tracts$geometry)

```

### Join Tract Level Data to Blocks  

My intentions for this part of the workflow were to generate a layer of centroids for the block data so I could join the population data to the tracts. I would do this two times. Once for the original tracts layer and a second time after I intersect the tracts with the voronoi diagram. I successfully generate a list of centroids for every block but when I join the centroids to the tracts layer, R makes a row for every centroid that was joined to a tract. This more than double the amount of observation in the data table. 

```{r centroids, warning = FALSE}

# Generate centroids for the blocks

cent_gen <- st_centroid(chi_pop)

centroids <- cent_gen %>%
  dplyr::select(TRACTCE20, BLOCKCE20, POP20)

```

```{r centroids-to-tracts, warning = FALSE}

# Join block centroids to tracts to calculate population data for the tract

tr_cent <- st_join(fc_tracts, centroids)%>%
  dplyr::select(TRACTCE, POP20)%>%
  group_by(TRACTCE)%>%
  summarize(sumPOP = sum(POP20))%>%
  st_drop_geometry()

# map 
# tmap_mode("plot")
# tm_shape(tr_cent) +
#   tm_polygons(col="sumPOP", style= "jenks", title="Population Tract", lwd= NA, border.col="lightgrey") +
# tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

#join pop data to acs table

acs_tracts <-
 left_join(fc_tracts, tr_cent, by = "TRACTCE")%>%
  dplyr::filter(sumPOP > 0)

```

```{r lib-id}

# Join library data to centroids and select for variables that I want to keep 

lib_ids <- st_join(centroids, vor_chi)%>%
              dplyr::select(TRACTCE20, BLOCKCE20, POP20, NAME)

```


```{r join-trct-to-blcks}
# Join soc variables to blocks with libids

f_blocks <- st_join(lib_ids, acs_tracts)

f_blocks <- f_blocks %>%
             mutate(prPOP = POP20/sumPOP,
                    pr_minc = B19013_001E * prPOP,
                    pr_black = black * prPOP, 
                    pr_for1 = for1 * prPOP) %>%
             group_by(NAME) %>%
             summarize(sum_minc = sum(pr_minc),
                       sum_black = sum(pr_black),
                       sum_for = sum(pr_for1)) %>%
             st_drop_geometry()


# after I group by and summarize i just need to join that data by a unique id back to the catchment area geometry so I can map with it

s_areas <- left_join(vor_chi, f_blocks, by= "NAME")%>%
            dplyr::select(NAME, Census.Tracts, sum_minc, sum_black, sum_for)
              
```

```{r map-s_areas}
tmap_mode("plot")
tm_shape(s_areas) +
  tm_polygons(col="sum_minc", title="Med. Household Income", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

tmap_mode("plot")
tm_shape(s_areas) +
  tm_polygons(col="sum_black", title="Black", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

tmap_mode("plot")
tm_shape(s_areas) +
  tm_polygons(col="sum_for", title="Foreign", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)
```
### Joining my website data
```{r}
```

## Maps for Pete, Friday 1/26/2024
```{r median-income-map}

m_inc_acs <- get_acs(
   geography = "tract",
   table = "B19013",
   county = "Cook",
   state = "IL",
   year = 2021,
   output = "wide",
   cache_table = TRUE,
   geometry = TRUE,
   keep_geo_vars = TRUE) %>%
   st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

hist(m_inc_acs$B19013_001E)

m_inc_trct <- left_join(m_inc_acs, tr_cent, by = "TRACTCE")%>%
  dplyr::filter(sumPOP > 0)

m_inc_trct <- mutate(m_inc_trct, m_inc_pc= B19013_001E/sumPOP )

brks_prty <- classIntervals(m_inc_trct$B19013_001E, 6, style = "jenks")$brks

#qtm(m_inc_shp, fill = "B19013_001E", fill.palette = "RdYlGn")

class(m_inc_trct)

tmap_mode("plot")
tm_shape(m_inc_trct) +
  tm_polygons(col="B19013_001E", breaks=brks_prty, title="Med. Household Income", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

```

```{r maj-race-map}
#load in acs data
race_acs2 <- get_acs(
    geography = "tract",
    table = "B02001",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

#rename column names
race_acs2$white <- c(race_acs2$B02001_002E)
race_acs2$black <- c(race_acs2$B02001_003E)
race_acs2$native <- c(race_acs2$B02001_004E)
race_acs2$asian <- c(race_acs2$B02001_005E)
race_acs2$hawpi <- c(race_acs2$B02001_006E)
race_acs2$other <- c(race_acs2$B02001_007E)
race_acs2$mixed <- c(race_acs2$B02001_008E+ 
                      race_acs2$B02001_009E + 
                      race_acs2$B02001_010E)

#join pop data to 
race_pop <- left_join(race_acs2, tr_cent, by = "TRACTCE")%>%
  dplyr::filter(sumPOP > 0)

#field calculate percents 

race_pop <- mutate(race_pop, pctBlack= black/sumPOP )%>%
            mutate(race_pop, pctWhite= white/sumPOP)%>%
            mutate(race_pop, pctAsian= asian/sumPOP)%>%
            mutate(race_pop, pctMixed= mixed/sumPOP)


race_pop <- mutate(race_pop, majRace = case_when(
             pctWhite > .60 ~ 'White',
             pctBlack > .60 ~ 'Black',
             pctAsian > .60 ~ 'Asian',
             pctMixed > .60 ~ 'Mixed',
             TRUE ~ 'Other'))

#map 
tmap_mode("plot")
tm_shape(race_pop) +
  tm_polygons(col="majRace", title="Racial Majority", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

```
```{r nativity}

nat_acs <- get_acs(
    geography = "tract",
    table = "B05012",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

nat_acs$for0 <- c(nat_acs$B05012_002E)
 nat_acs$for1 <- c(nat_acs$B05012_003E)
 
 #join pop data to 
 
nat_pop <- left_join(nat_acs, tr_cent, by = "TRACTCE")%>%
  dplyr::filter(sumPOP > 0)

nat_pop <- mutate(nat_pop, pctFor= for1/sumPOP )%>%
            mutate(nat_pop, pctNat= for0/sumPOP)
          
# nat_pop <- mutate(nat_pop, majBorn = case_when(
#              pctFor > .51 ~ 'Maj Foreign',
#              pctNat > .51 ~ 'Maj Native',
#              TRUE ~ 'Other'))

#map 
tmap_mode("plot")
tm_shape(nat_pop) +
  tm_polygons(col="pctFor", title="Pct Foreign", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)


```
```{r map-emp}
emp_acs2 <- get_acs(
    geography = "tract",
    table = "B23025",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

emp_acs2$emp0 <- emp_acs2$B23025_007E
emp_acs2$emp1 <- emp_acs2$B23025_002E

#join pop data to 
 
emp_pop <- left_join(emp_acs2, tr_cent, by = "TRACTCE")%>%
  dplyr::filter(sumPOP > 0)

emp_pop <- mutate(emp_pop, pctEmp= emp1/sumPOP )%>%
            mutate(emp_pop, pctUnemp= emp0/sumPOP)

#nat

tmap_mode("plot")
tm_shape(emp_pop) +
  tm_polygons(col="pctEmp", title="Pct Employed per Capita", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

tmap_mode("plot")
tm_shape(emp_pop) +
  tm_polygons(col="pctUnemp", title="Pct Unemployed per Capita", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)



```
```{r lang-map}
lang_acs <- get_acs(
     geography = "tract",
     table = "B06007",
     county = "Cook",
     state = "IL",
     year = 2016,
     output = "wide",
     cache_table = TRUE,
     geometry = TRUE,
     keep_geo_vars = TRUE)%>%
    st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

lang_acs$lang1 <- lang_acs$B06007_002E
lang_acs$lang2 <- lang_acs$B06007_003E
lang_acs$lang3 <- lang_acs$B06007_006E

lang_acs$lang4 <- c(lang_acs$B06007_004E + 
                  lang_acs$B06007_007E)

lang_acs$lang5 <- c(lang_acs$B06007_005E + 
                  lang_acs$B06007_008E)

#join pop data to 
 
lang_pop <- left_join(lang_acs, tr_cent, by = "TRACTCE")%>%
  dplyr::filter(sumPOP > 0)

lang_pop <- mutate(lang_pop, pctEng= lang1/sumPOP )%>%
            mutate(lang_pop, pctSpan= lang2/sumPOP)%>%
            mutate(lang_pop, pctOther= lang3/sumPOP)%>%
            mutate(lang_pop, pctWell= lang4/sumPOP)%>%
            mutate(lang_pop, pctNWell= lang5/sumPOP)

#case
race_pop <- mutate(lang_pop, majLang = case_when(
             pctWell > .60 ~ 'Very Well',
             pctNWell > .60 ~ 'Not Very Well',
             TRUE ~ 'Other'))
#map

tmap_mode("plot")
tm_shape(race_pop) +
  tm_polygons(col="pctSpan", title="Pct Spanish Speakers", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

tmap_mode("plot")
tm_shape(race_pop) +
  tm_polygons(col="pctOther", title="Pct Other Language", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

tmap_mode("plot")
tm_shape(race_pop) +
  tm_polygons(col="pctNWell", title="Pct Speak English Not Very Well", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)


```

```{r edu-att-map}

 edu_acs <- get_acs(
    geography = "tract",
    table = "B15003",
    county = "Cook",
    state = "IL",
    year = 2021,
    output = "wide",
    cache_table = TRUE,
    geometry = TRUE,
    keep_geo_vars = TRUE)%>%
    st_set_crs(st_crs("+proj=utm +zone=16 +datum=WGS84"))

edu_acs$et1 <- c(edu_acs$B15003_002E +
                    edu_acs$B15003_003E +
                    edu_acs$B15003_004E +
                    edu_acs$B15003_005E +
                    edu_acs$B15003_006E +
                    edu_acs$B15003_007E +
                    edu_acs$B15003_008E +
                    edu_acs$B15003_009E +
                    edu_acs$B15003_010E +
                    edu_acs$B15003_011E +
                    edu_acs$B15003_012E +
                    edu_acs$B15003_013E +
                    edu_acs$B15003_014E +
                    edu_acs$B15003_015E +
                    edu_acs$B15003_016E)

 edu_acs$et2 <- c(edu_acs$B15003_017E +
                    edu_acs$B15003_018E +
                    edu_acs$B15003_019E +
                    edu_acs$B15003_020E)

 edu_acs$et3 <- c(edu_acs$B15003_021E +
                    edu_acs$B15003_022E)

 edu_acs$et4 <- c(edu_acs$B15003_023E +
                    edu_acs$B15003_024E +
                    edu_acs$B15003_025E)
 #join pop data to 
edu_pop <- left_join(edu_acs, tr_cent, by = "TRACTCE")%>%
  dplyr::filter(sumPOP > 0)

#field calculate percents 

edu_pop <- mutate(edu_pop, pctET1= et1/sumPOP )%>%
            mutate(edu_pop, pctET2= et2/sumPOP)%>%
            mutate(edu_pop, pctET3= et3/sumPOP)%>%
            mutate(edu_pop, pctET4= et4/sumPOP)

# edu_pop <- mutate(edu_pop, majET = case_when(
#              pctET1 > .50 ~ 'no hs dip',
#              pctET2 > .50 ~ 'hs dip or eq',
#              pctET3 > .50 ~ 'as or bac',
#              pctET4 > .50 ~ 'grad or prof'))

tmap_mode("plot")
tm_shape(edu_pop) +
  tm_polygons(col="pctET1", title="Pct No High Dip", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

tmap_mode("plot")
tm_shape(edu_pop) +
  tm_polygons(col="pctET2", title="Pct High Dip or Eq", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

tmap_mode("plot")
tm_shape(edu_pop) +
  tm_polygons(col="pctET3", title="Pct Assoc. or Bach.", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)

tmap_mode("plot")
tm_shape(edu_pop) +
  tm_polygons(col="pctET4", title="Pct Grad or Prof", lwd= 0, border.col="lightgrey") +
tm_layout(legend.width=3, legend.text.size = .6, legend.title.size = .8, asp=0.8)


```


# Results

Results currently unavailable until I can debug my population weighted aggregation workflow. 

# Discussion

Discussion currently unavailable until I can debug my population weighted aggregation workflow. 

# Integrity Statement

The authors of this preregistration state that they completed this preregistration to the best of their knowledge and that no other preregistration exists pertaining to the same hypotheses and research.

This report is based upon the template for Reproducible and Replicable Research in Human-Environment and Geographical Sciences, DOI:[10.17605/OSF.IO/W29MQ](https://doi.org/10.17605/OSF.IO/W29MQ)

# References
Flitter, H., Weckenbrock, P., & Weibel, R. (n.d.). Thiessen Polygon. Retrieved December 16, 2023, from http://www.gitta.info/Accessibilit/en/html/UncProxAnaly_learningObject4.html
